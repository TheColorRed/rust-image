use regex::Regex;
use std::env;
use std::fs;
use std::path::PathBuf;

pub fn color_list() {
  // Location of the core colors file, relative to this crate
  let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
  let colors_path = PathBuf::from(manifest_dir)
    .join("..") // packages/abra -> packages
    .join("core")
    .join("core")
    .join("src")
    .join("color")
    .join("colors_list.rs");

  // Read the source file
  let colors_src =
    fs::read_to_string(&colors_path).unwrap_or_else(|_| panic!("Could not open {}", colors_path.display()));

  // Find all pub fn <name>() -> Self occurrences
  let re = Regex::new(r"pub\s+fn\s+([a-z0-9_]+)\s*\(\s*\)\s*->\s*Self").unwrap();

  let mut mappings = Vec::new();
  for cap in re.captures_iter(&colors_src) {
    let fn_name = &cap[1];
    // produce abra_color_<name> mapping
    mappings.push(format!("  abra_color_{} => {},", fn_name, fn_name));
  }

  if mappings.is_empty() {
    // If none found, fail nicely and give a hint
    panic!("No color functions found in {}", colors_path.display());
  }

  // Generate the output file in OUT_DIR
  let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
  let out_file = out_dir.join("generated_color_list.rs");

  let mut file_contents = String::new();
  file_contents.push_str("// This file is generated by build.rs - do not edit.\n");
  file_contents.push_str("// Generated color_list! macro invocation\n");
  file_contents.push_str("macro_rules! color_list {\n");
  file_contents.push_str("  ( $( $fn_name:ident => $color_name:ident ),* $(,)? ) => {\n");
  file_contents.push_str("    $(\n");
  file_contents.push_str("      #[unsafe(no_mangle)]\n");
  file_contents.push_str("      pub extern \"C\" fn $fn_name() -> *mut Color {\n");
  file_contents.push_str("        box_ffi!(Color::$color_name())\n");
  file_contents.push_str("      }\n");
  file_contents.push_str("    )*\n");
  file_contents.push_str("  };\n");
  file_contents.push_str("}\n");
  file_contents.push_str("color_list!(\n");
  file_contents.push_str(&mappings.join("\n"));
  file_contents.push_str("\n);");

  // Tell cargo to re-run this build script if the core colors file changes
  println!("cargo:rerun-if-changed={}", colors_path.display());
  // and also if this build script changes
  println!("cargo:rerun-if-changed=build.rs");
  // Use cargo:warning= to make the path visible in normal cargo output
  println!("cargo:warning=output file: {}", out_file.display());
  fs::write(&out_file, file_contents).unwrap_or_else(|_| panic!("Could not write {}", out_file.display()));
}
